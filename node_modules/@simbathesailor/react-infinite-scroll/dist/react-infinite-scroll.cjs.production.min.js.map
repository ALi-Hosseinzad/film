{"version":3,"file":"react-infinite-scroll.cjs.production.min.js","sources":["../src/useRefCallback.ts","../src/useIntersectionObserver.tsx","../src/useInfiniteScroll.tsx","../src/useHotRefs.ts"],"sourcesContent":["import React from 'react';\nimport { IRefFunctionCallback } from './types';\n\nfunction useRefCallback(): [null | HTMLElement, Function] {\n  const [elem, setElem] = React.useState(null);\n  const elemCallbackRef: IRefFunctionCallback = React.useCallback(elem => {\n    setElem(elem);\n    elemCallbackRef.current = elem;\n  }, []);\n  return [elem, elemCallbackRef];\n}\n\nexport default useRefCallback;\n","import React from 'react';\nimport useRefCallback from './useRefCallback';\n\nconst initialState = {\n  intersectionObj: {},\n  observerInState: null,\n  isVisible: false,\n};\n\ninterface Iaction {\n  type: string;\n  data: any;\n}\ninterface Window {\n  IntersectionObserver: Function;\n}\nfunction IntersectionObserverReducer(state: any, action: Iaction) {\n  switch (action.type) {\n    case 'SETINTERSECTIONOBJ': {\n      return {\n        ...state,\n        intersectionObj: action.data,\n      };\n    }\n    case 'SETOBSERVERHANDLE': {\n      return {\n        ...state,\n        observerInState: action.data,\n      };\n    }\n    case 'SET_VISIBILITY': {\n      return {\n        ...state,\n        isVisible: action.data,\n      };\n    }\n  }\n}\n\nconst checkFeasibility = () => {\n  // let windowMY: IWindow = window;\n  let MyWindow: Window = window;\n  if (!MyWindow || !MyWindow.IntersectionObserver) {\n    console.warn(\n      'Intersection Observer is not supported in the current browser / environment'\n    );\n    return false;\n  }\n  return true;\n};\ninterface IOptions {\n  rootMargin?: string;\n  threshold?: string;\n  when?: boolean;\n  callback?: Function;\n  visibilityCondition?: (entry: IntersectionObserverEntry) => boolean;\n}\n\ntype useIntersectionObserverReturn = [boolean, any, any];\n\n/***\n * To use the the intersection Observer\n * visibiltyCondition call back can sent , which will be having access to\n * intersection entry object\n * Read https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n * about various attributes provided by entries\n * Each entry describes an intersection change for one observed\n *  target element:\n *  entry.boundingClientRect\n *  entry.intersectionRatio\n *  entry.intersectionRect\n *  entry.isIntersecting\n *  entry.rootBounds\n *  entry.target\n *  entry.time\n */\nconst defaultVisibilityCondition = (entry: IntersectionObserverEntry) => {\n  if (entry.intersectionRatio >= 1) {\n    return true;\n  }\n  return false;\n};\n\nconst defaultOptions = {\n  rootMargin: '0px 0px 0px 0px',\n  threshold: '0, 1',\n  when: true,\n  visibilityCondition: defaultVisibilityCondition,\n};\n\n// function useRefCallback(): [null | HTMLElement, Function] {\n//   const [elem, setELem] = React.useState(null);\n//   const elemCallbackRef: IRefFunctionCallback = React.useCallback(elem => {\n//     setELem(elem);\n//     elemCallbackRef.current = elem;\n//   }, []);\n//   return [elem, elemCallbackRef];\n// }\nfunction useIntersectionObserver(\n  options: IOptions\n): useIntersectionObserverReturn {\n  const { rootMargin, threshold, when, callback, visibilityCondition } = {\n    ...defaultOptions,\n    ...options,\n  };\n  const [rootElemNew, rootCallbackRef] = useRefCallback();\n  const [boxElem, boxElemCallback] = useRefCallback();\n\n  const [state, dispatch] = React.useReducer(\n    IntersectionObserverReducer,\n    initialState\n  );\n\n  const { observerInState, isVisible } = state;\n\n  const observerRef = React.useRef<any>(null);\n  const callbackRef = React.useRef<any>(null);\n\n  function callbackResolved(\n    entries: IntersectionObserverEntry[],\n    observer: IntersectionObserver\n  ): any {\n    entries.forEach((entry: IntersectionObserverEntry) => {\n      // setIntersectionObj(entry);\n      dispatch({\n        type: 'SETINTERSECTIONOBJ',\n        data: entry,\n      });\n      if (!observerInState) {\n        dispatch({\n          type: 'SETOBSERVERHANDLE',\n          data: observer,\n        });\n        // setObserver(observer);\n      }\n      let finalVisibilityFunction = defaultVisibilityCondition;\n      if (visibilityCondition) {\n        finalVisibilityFunction = visibilityCondition;\n      }\n      dispatch({\n        type: 'SET_VISIBILITY',\n        data: finalVisibilityFunction(entry),\n      });\n      // Each entry describes an intersection change for one observed\n      // target element:\n      //   entry.boundingClientRect\n      //   entry.intersectionRatio\n      //   entry.intersectionRect\n      //   entry.isIntersecting\n      //   entry.rootBounds\n      //   entry.target\n      //   entry.time\n    });\n  }\n  const newCallbackDefault = React.useRef(callbackResolved);\n  React.useEffect(() => {\n    newCallbackDefault.current = callbackResolved;\n  });\n  /**\n   * Setting callback Ref\n   */\n\n  React.useEffect(() => {\n    if (!checkFeasibility) {\n      return;\n    }\n    if (!callback) {\n      let callbackDefault = newCallbackDefault.current;\n      callbackRef.current = callbackDefault;\n    } else {\n      callbackRef.current = callback;\n    }\n  }, [callback, visibilityCondition, newCallbackDefault]);\n\n  /**\n   * unobserving intersectionobserver when \"when\" key is false\n   */\n  React.useEffect(() => {\n    if (!checkFeasibility) {\n      return;\n    }\n    if (!when) {\n      if (observerRef.current && observerRef.current != null && boxElem) {\n        observerRef.current.unobserve(boxElem);\n      }\n    }\n  }, [observerRef, boxElem, when]);\n\n  /**\n   * Effect responsible for creating intersection observer and\n   * registering the observer for specific element\n   */\n  React.useEffect(() => {\n    if (!checkFeasibility) {\n      return;\n    }\n    const currentELem = boxElem;\n    const currentRootElem = rootElemNew;\n    if (when) {\n      let observer = new IntersectionObserver(callbackRef.current, {\n        root: currentRootElem || null,\n        threshold: threshold.split(',').map(elem => parseFloat(elem)),\n        rootMargin,\n      });\n      observerRef.current = observer;\n\n      if (currentELem && observerRef.current) {\n        observerRef.current.observe(currentELem);\n      }\n    }\n    return () => {\n      if (currentELem && observerRef.current) {\n        observerRef.current.unobserve(currentELem);\n      }\n    };\n  }, [boxElem, rootElemNew, rootMargin, when, callbackRef, threshold]);\n  return [isVisible, boxElemCallback, rootCallbackRef];\n}\n\nexport default useIntersectionObserver;\n","import React from 'react';\nimport useIntersectionObserver from './useIntersectionObserver';\nimport useHotRefs from './useHotRefs';\n\nconst defaultVisibilityCondition = (entry: IntersectionObserverEntry) => {\n  if (entry.intersectionRatio >= 1) {\n    return true;\n  }\n  return false;\n};\n\nconst defaultOptions = {\n  rootMargin: '0px 0px 0px 0px',\n  threshold: '0, 1',\n  when: true,\n  visibilityCondition: defaultVisibilityCondition,\n};\n\ninterface IOptions {\n  rootMargin?: string;\n  threshold?: string;\n  when?: boolean;\n  visibilityCondition?: (entry: IntersectionObserverEntry) => boolean;\n}\n\nfunction LoadingMore() {\n  return <h1>Loading More...</h1>;\n}\n\n/**\n * Custom useInfiniteScroll hook which use useIntersectionObserver custom hook\n *\n */\nfunction useInfiniteScroll(options?: IOptions) {\n  const [isVisible, boxElemCallback, rootCallbackRef] = useIntersectionObserver(\n    options || defaultOptions\n  );\n  return [boxElemCallback, isVisible, rootCallbackRef];\n}\n// type JSXElementArray = (JSX.Element | null)[] | [];\n// type JSXElementArray = (JSX.Element)[] | [] | null;\n// JSX.Element | JSX.Element[]\ntype JSXElementArray = React.ReactElement | React.ReactElement[];\n\ninterface IPropsInfiniteScroll {\n  callback?: (isVisible: boolean) => void;\n  options?: IOptions;\n  LoadMoreComponent?: React.ReactElement;\n  whenInfiniteScroll?: boolean;\n  children: JSX.Element[] | [];\n}\n\n/**\n * InfiniteScroll\n * @param props Infinite scroll component which uses above custom hooks\n */\n\nfunction InfiniteScroll(props: IPropsInfiniteScroll) {\n  const {\n    callback,\n    options = defaultOptions,\n    LoadMoreComponent = null,\n    whenInfiniteScroll = true,\n  } = props;\n  let finalOptions = { ...defaultOptions, ...options };\n  const [callbackRef] = useHotRefs(callback);\n\n  const [boxElemCallback, isVisible] = useInfiniteScroll({\n    ...finalOptions,\n    when: whenInfiniteScroll,\n  });\n\n  const callbackFixed = React.useCallback(\n    isVisible => {\n      if (whenInfiniteScroll && callbackRef.current) {\n        let currentFunction = callbackRef.current;\n        currentFunction(isVisible);\n      }\n    },\n    [callbackRef, whenInfiniteScroll]\n  );\n\n  React.useEffect(() => {\n    if (callbackFixed && whenInfiniteScroll) {\n      callbackFixed(isVisible);\n    }\n  }, [isVisible, callbackFixed, whenInfiniteScroll]);\n\n  let finalReturnChildren: JSXElementArray = [];\n\n  if (props.children) {\n    /**\n     * props.children can be  array like this, hence need to handle this scenario\n     * flatten the children array\n     * 0: {$$typeof: Symbol(react.element), type: \"h1\", key: null, ref: null, props: {…}, …}\n     * 1: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]\n     * \n     * In that case JSX will be like this : \n     * \n     * <Child>\n        <div>Hi</div>\n         <div>Hi</div>\n         <div>Hi</div>\n         {[1,2,3].map((elem, index) => {\n           return <div key={index}>{index}</div>\n         })}\n         <div>\n           \n          </div>\n      </Child>\n     */\n    let flattenChildren: JSX.Element[] = [];\n\n    React.Children.forEach(props.children, child => {\n      if (Array.isArray(child)) {\n        flattenChildren = [...flattenChildren, ...child];\n      } else {\n        flattenChildren = [...flattenChildren, child];\n      }\n    });\n\n    finalReturnChildren = React.Children.map(\n      flattenChildren,\n      (child, index) => {\n        const lastIndex = flattenChildren.length - 1;\n        if (index === lastIndex) {\n          //   if (!child) return null;\n          return React.cloneElement(child, {\n            ref: boxElemCallback,\n          });\n        }\n        return child;\n      }\n    ).filter(elem => elem);\n  }\n  if (isVisible && finalReturnChildren) {\n    finalReturnChildren = [\n      ...finalReturnChildren,\n      LoadMoreComponent ? (\n        React.cloneElement(LoadMoreComponent, {\n          key: Math.random(),\n        })\n      ) : (\n        <LoadingMore key={Math.random()} />\n        /**\n         * Need to think about the correct key value. because this\n         * key value may be same as one of the key in list item, right now using Math.random\n         */\n      ),\n    ];\n  }\n  return <React.Fragment>{finalReturnChildren}</React.Fragment>;\n}\n\n/**\n * Infinite scroll in any scrollable area : It will work for any scroll area,\n * as per the findings, It looks like the intersection area is clipped if there is any overflow\n * non-visible property. and hence the intersection area doesnot reach the viewport in that case\n * Read 'Clipping and the intersection rectangle' section here:\n * https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#root-intersection-rectangle\n */\n\nexport { InfiniteScroll };\n","import React from 'react';\n\n// React.MutableRefObject<{ current: any }>\nfunction useHotRefs(value: any): [any] {\n  const callbackRef = React.useRef(value);\n  React.useEffect(() => {\n    callbackRef.current = value;\n  });\n  return [callbackRef];\n}\n\nexport default useHotRefs;\n"],"names":["useRefCallback","React","useState","elem","setElem","elemCallbackRef","useCallback","current","initialState","intersectionObj","observerInState","isVisible","IntersectionObserverReducer","state","action","type","data","checkFeasibility","MyWindow","window","IntersectionObserver","console","warn","defaultVisibilityCondition","entry","intersectionRatio","defaultOptions","rootMargin","threshold","when","visibilityCondition","LoadingMore","createElement","props","callback","options","LoadMoreComponent","whenInfiniteScroll","finalOptions","callbackRef","value","useRef","useEffect","useHotRefs","rootElemNew","rootCallbackRef","boxElem","boxElemCallback","useReducer","dispatch","observerRef","callbackResolved","entries","observer","forEach","finalVisibilityFunction","newCallbackDefault","unobserve","currentELem","root","split","map","parseFloat","observe","useIntersectionObserver","callbackFixed","currentFunction","finalReturnChildren","children","flattenChildren","Children","child","Array","isArray","index","length","cloneElement","ref","filter","key","Math","random","Fragment"],"mappings":"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"}