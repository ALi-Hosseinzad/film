{"version":3,"file":"react-infinite-scroll.esm.js","sources":["../src/useRefCallback.ts","../src/useIntersectionObserver.tsx","../src/useHotRefs.ts","../src/useInfiniteScroll.tsx"],"sourcesContent":["import React from 'react';\nimport { IRefFunctionCallback } from './types';\n\nfunction useRefCallback(): [null | HTMLElement, Function] {\n  const [elem, setElem] = React.useState(null);\n  const elemCallbackRef: IRefFunctionCallback = React.useCallback(elem => {\n    setElem(elem);\n    elemCallbackRef.current = elem;\n  }, []);\n  return [elem, elemCallbackRef];\n}\n\nexport default useRefCallback;\n","import React from 'react';\nimport useRefCallback from './useRefCallback';\n\nconst initialState = {\n  intersectionObj: {},\n  observerInState: null,\n  isVisible: false,\n};\n\ninterface Iaction {\n  type: string;\n  data: any;\n}\ninterface Window {\n  IntersectionObserver: Function;\n}\nfunction IntersectionObserverReducer(state: any, action: Iaction) {\n  switch (action.type) {\n    case 'SETINTERSECTIONOBJ': {\n      return {\n        ...state,\n        intersectionObj: action.data,\n      };\n    }\n    case 'SETOBSERVERHANDLE': {\n      return {\n        ...state,\n        observerInState: action.data,\n      };\n    }\n    case 'SET_VISIBILITY': {\n      return {\n        ...state,\n        isVisible: action.data,\n      };\n    }\n  }\n}\n\nconst checkFeasibility = () => {\n  // let windowMY: IWindow = window;\n  let MyWindow: Window = window;\n  if (!MyWindow || !MyWindow.IntersectionObserver) {\n    console.warn(\n      'Intersection Observer is not supported in the current browser / environment'\n    );\n    return false;\n  }\n  return true;\n};\ninterface IOptions {\n  rootMargin?: string;\n  threshold?: string;\n  when?: boolean;\n  callback?: Function;\n  visibilityCondition?: (entry: IntersectionObserverEntry) => boolean;\n}\n\ntype useIntersectionObserverReturn = [boolean, any, any];\n\n/***\n * To use the the intersection Observer\n * visibiltyCondition call back can sent , which will be having access to\n * intersection entry object\n * Read https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n * about various attributes provided by entries\n * Each entry describes an intersection change for one observed\n *  target element:\n *  entry.boundingClientRect\n *  entry.intersectionRatio\n *  entry.intersectionRect\n *  entry.isIntersecting\n *  entry.rootBounds\n *  entry.target\n *  entry.time\n */\nconst defaultVisibilityCondition = (entry: IntersectionObserverEntry) => {\n  if (entry.intersectionRatio >= 1) {\n    return true;\n  }\n  return false;\n};\n\nconst defaultOptions = {\n  rootMargin: '0px 0px 0px 0px',\n  threshold: '0, 1',\n  when: true,\n  visibilityCondition: defaultVisibilityCondition,\n};\n\n// function useRefCallback(): [null | HTMLElement, Function] {\n//   const [elem, setELem] = React.useState(null);\n//   const elemCallbackRef: IRefFunctionCallback = React.useCallback(elem => {\n//     setELem(elem);\n//     elemCallbackRef.current = elem;\n//   }, []);\n//   return [elem, elemCallbackRef];\n// }\nfunction useIntersectionObserver(\n  options: IOptions\n): useIntersectionObserverReturn {\n  const { rootMargin, threshold, when, callback, visibilityCondition } = {\n    ...defaultOptions,\n    ...options,\n  };\n  const [rootElemNew, rootCallbackRef] = useRefCallback();\n  const [boxElem, boxElemCallback] = useRefCallback();\n\n  const [state, dispatch] = React.useReducer(\n    IntersectionObserverReducer,\n    initialState\n  );\n\n  const { observerInState, isVisible } = state;\n\n  const observerRef = React.useRef<any>(null);\n  const callbackRef = React.useRef<any>(null);\n\n  function callbackResolved(\n    entries: IntersectionObserverEntry[],\n    observer: IntersectionObserver\n  ): any {\n    entries.forEach((entry: IntersectionObserverEntry) => {\n      // setIntersectionObj(entry);\n      dispatch({\n        type: 'SETINTERSECTIONOBJ',\n        data: entry,\n      });\n      if (!observerInState) {\n        dispatch({\n          type: 'SETOBSERVERHANDLE',\n          data: observer,\n        });\n        // setObserver(observer);\n      }\n      let finalVisibilityFunction = defaultVisibilityCondition;\n      if (visibilityCondition) {\n        finalVisibilityFunction = visibilityCondition;\n      }\n      dispatch({\n        type: 'SET_VISIBILITY',\n        data: finalVisibilityFunction(entry),\n      });\n      // Each entry describes an intersection change for one observed\n      // target element:\n      //   entry.boundingClientRect\n      //   entry.intersectionRatio\n      //   entry.intersectionRect\n      //   entry.isIntersecting\n      //   entry.rootBounds\n      //   entry.target\n      //   entry.time\n    });\n  }\n  const newCallbackDefault = React.useRef(callbackResolved);\n  React.useEffect(() => {\n    newCallbackDefault.current = callbackResolved;\n  });\n  /**\n   * Setting callback Ref\n   */\n\n  React.useEffect(() => {\n    if (!checkFeasibility) {\n      return;\n    }\n    if (!callback) {\n      let callbackDefault = newCallbackDefault.current;\n      callbackRef.current = callbackDefault;\n    } else {\n      callbackRef.current = callback;\n    }\n  }, [callback, visibilityCondition, newCallbackDefault]);\n\n  /**\n   * unobserving intersectionobserver when \"when\" key is false\n   */\n  React.useEffect(() => {\n    if (!checkFeasibility) {\n      return;\n    }\n    if (!when) {\n      if (observerRef.current && observerRef.current != null && boxElem) {\n        observerRef.current.unobserve(boxElem);\n      }\n    }\n  }, [observerRef, boxElem, when]);\n\n  /**\n   * Effect responsible for creating intersection observer and\n   * registering the observer for specific element\n   */\n  React.useEffect(() => {\n    if (!checkFeasibility) {\n      return;\n    }\n    const currentELem = boxElem;\n    const currentRootElem = rootElemNew;\n    if (when) {\n      let observer = new IntersectionObserver(callbackRef.current, {\n        root: currentRootElem || null,\n        threshold: threshold.split(',').map(elem => parseFloat(elem)),\n        rootMargin,\n      });\n      observerRef.current = observer;\n\n      if (currentELem && observerRef.current) {\n        observerRef.current.observe(currentELem);\n      }\n    }\n    return () => {\n      if (currentELem && observerRef.current) {\n        observerRef.current.unobserve(currentELem);\n      }\n    };\n  }, [boxElem, rootElemNew, rootMargin, when, callbackRef, threshold]);\n  return [isVisible, boxElemCallback, rootCallbackRef];\n}\n\nexport default useIntersectionObserver;\n","import React from 'react';\n\n// React.MutableRefObject<{ current: any }>\nfunction useHotRefs(value: any): [any] {\n  const callbackRef = React.useRef(value);\n  React.useEffect(() => {\n    callbackRef.current = value;\n  });\n  return [callbackRef];\n}\n\nexport default useHotRefs;\n","import React from 'react';\nimport useIntersectionObserver from './useIntersectionObserver';\nimport useHotRefs from './useHotRefs';\n\nconst defaultVisibilityCondition = (entry: IntersectionObserverEntry) => {\n  if (entry.intersectionRatio >= 1) {\n    return true;\n  }\n  return false;\n};\n\nconst defaultOptions = {\n  rootMargin: '0px 0px 0px 0px',\n  threshold: '0, 1',\n  when: true,\n  visibilityCondition: defaultVisibilityCondition,\n};\n\ninterface IOptions {\n  rootMargin?: string;\n  threshold?: string;\n  when?: boolean;\n  visibilityCondition?: (entry: IntersectionObserverEntry) => boolean;\n}\n\nfunction LoadingMore() {\n  return <h1>Loading More...</h1>;\n}\n\n/**\n * Custom useInfiniteScroll hook which use useIntersectionObserver custom hook\n *\n */\nfunction useInfiniteScroll(options?: IOptions) {\n  const [isVisible, boxElemCallback, rootCallbackRef] = useIntersectionObserver(\n    options || defaultOptions\n  );\n  return [boxElemCallback, isVisible, rootCallbackRef];\n}\n// type JSXElementArray = (JSX.Element | null)[] | [];\n// type JSXElementArray = (JSX.Element)[] | [] | null;\n// JSX.Element | JSX.Element[]\ntype JSXElementArray = React.ReactElement | React.ReactElement[];\n\ninterface IPropsInfiniteScroll {\n  callback?: (isVisible: boolean) => void;\n  options?: IOptions;\n  LoadMoreComponent?: React.ReactElement;\n  whenInfiniteScroll?: boolean;\n  children: JSX.Element[] | [];\n}\n\n/**\n * InfiniteScroll\n * @param props Infinite scroll component which uses above custom hooks\n */\n\nfunction InfiniteScroll(props: IPropsInfiniteScroll) {\n  const {\n    callback,\n    options = defaultOptions,\n    LoadMoreComponent = null,\n    whenInfiniteScroll = true,\n  } = props;\n  let finalOptions = { ...defaultOptions, ...options };\n  const [callbackRef] = useHotRefs(callback);\n\n  const [boxElemCallback, isVisible] = useInfiniteScroll({\n    ...finalOptions,\n    when: whenInfiniteScroll,\n  });\n\n  const callbackFixed = React.useCallback(\n    isVisible => {\n      if (whenInfiniteScroll && callbackRef.current) {\n        let currentFunction = callbackRef.current;\n        currentFunction(isVisible);\n      }\n    },\n    [callbackRef, whenInfiniteScroll]\n  );\n\n  React.useEffect(() => {\n    if (callbackFixed && whenInfiniteScroll) {\n      callbackFixed(isVisible);\n    }\n  }, [isVisible, callbackFixed, whenInfiniteScroll]);\n\n  let finalReturnChildren: JSXElementArray = [];\n\n  if (props.children) {\n    /**\n     * props.children can be  array like this, hence need to handle this scenario\n     * flatten the children array\n     * 0: {$$typeof: Symbol(react.element), type: \"h1\", key: null, ref: null, props: {…}, …}\n     * 1: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]\n     * \n     * In that case JSX will be like this : \n     * \n     * <Child>\n        <div>Hi</div>\n         <div>Hi</div>\n         <div>Hi</div>\n         {[1,2,3].map((elem, index) => {\n           return <div key={index}>{index}</div>\n         })}\n         <div>\n           \n          </div>\n      </Child>\n     */\n    let flattenChildren: JSX.Element[] = [];\n\n    React.Children.forEach(props.children, child => {\n      if (Array.isArray(child)) {\n        flattenChildren = [...flattenChildren, ...child];\n      } else {\n        flattenChildren = [...flattenChildren, child];\n      }\n    });\n\n    finalReturnChildren = React.Children.map(\n      flattenChildren,\n      (child, index) => {\n        const lastIndex = flattenChildren.length - 1;\n        if (index === lastIndex) {\n          //   if (!child) return null;\n          return React.cloneElement(child, {\n            ref: boxElemCallback,\n          });\n        }\n        return child;\n      }\n    ).filter(elem => elem);\n  }\n  if (isVisible && finalReturnChildren) {\n    finalReturnChildren = [\n      ...finalReturnChildren,\n      LoadMoreComponent ? (\n        React.cloneElement(LoadMoreComponent, {\n          key: Math.random(),\n        })\n      ) : (\n        <LoadingMore key={Math.random()} />\n        /**\n         * Need to think about the correct key value. because this\n         * key value may be same as one of the key in list item, right now using Math.random\n         */\n      ),\n    ];\n  }\n  return <React.Fragment>{finalReturnChildren}</React.Fragment>;\n}\n\n/**\n * Infinite scroll in any scrollable area : It will work for any scroll area,\n * as per the findings, It looks like the intersection area is clipped if there is any overflow\n * non-visible property. and hence the intersection area doesnot reach the viewport in that case\n * Read 'Clipping and the intersection rectangle' section here:\n * https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#root-intersection-rectangle\n */\n\nexport { InfiniteScroll };\n"],"names":["useRefCallback","React","useState","elem","setElem","elemCallbackRef","useCallback","current","initialState","intersectionObj","observerInState","isVisible","IntersectionObserverReducer","state","action","type","data","checkFeasibility","MyWindow","window","IntersectionObserver","console","warn","defaultVisibilityCondition","entry","intersectionRatio","defaultOptions","rootMargin","threshold","when","visibilityCondition","useIntersectionObserver","options","callback","rootElemNew","rootCallbackRef","boxElem","boxElemCallback","useReducer","dispatch","observerRef","useRef","callbackRef","callbackResolved","entries","observer","forEach","finalVisibilityFunction","newCallbackDefault","useEffect","callbackDefault","unobserve","currentELem","currentRootElem","root","split","map","parseFloat","observe","useHotRefs","value","LoadingMore","createElement","useInfiniteScroll","InfiniteScroll","props","LoadMoreComponent","whenInfiniteScroll","finalOptions","callbackFixed","currentFunction","finalReturnChildren","children","flattenChildren","Children","child","Array","isArray","index","lastIndex","length","cloneElement","ref","filter","key","Math","random","Fragment"],"mappings":"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"}