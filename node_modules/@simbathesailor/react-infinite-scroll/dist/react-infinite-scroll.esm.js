import React from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function useRefCallback() {
  var _React$useState = React.useState(null),
      elem = _React$useState[0],
      setElem = _React$useState[1];

  var elemCallbackRef = React.useCallback(function (elem) {
    setElem(elem);
    elemCallbackRef.current = elem;
  }, []);
  return [elem, elemCallbackRef];
}

var initialState = {
  intersectionObj: {},
  observerInState: null,
  isVisible: false
};

function IntersectionObserverReducer(state, action) {
  switch (action.type) {
    case 'SETINTERSECTIONOBJ':
      {
        return _extends({}, state, {
          intersectionObj: action.data
        });
      }

    case 'SETOBSERVERHANDLE':
      {
        return _extends({}, state, {
          observerInState: action.data
        });
      }

    case 'SET_VISIBILITY':
      {
        return _extends({}, state, {
          isVisible: action.data
        });
      }
  }
}

var checkFeasibility = function checkFeasibility() {
  // let windowMY: IWindow = window;
  var MyWindow = window;

  if (!MyWindow || !MyWindow.IntersectionObserver) {
    console.warn('Intersection Observer is not supported in the current browser / environment');
    return false;
  }

  return true;
};
/***
 * To use the the intersection Observer
 * visibiltyCondition call back can sent , which will be having access to
 * intersection entry object
 * Read https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 * about various attributes provided by entries
 * Each entry describes an intersection change for one observed
 *  target element:
 *  entry.boundingClientRect
 *  entry.intersectionRatio
 *  entry.intersectionRect
 *  entry.isIntersecting
 *  entry.rootBounds
 *  entry.target
 *  entry.time
 */


var defaultVisibilityCondition = function defaultVisibilityCondition(entry) {
  if (entry.intersectionRatio >= 1) {
    return true;
  }

  return false;
};

var defaultOptions = {
  rootMargin: '0px 0px 0px 0px',
  threshold: '0, 1',
  when: true,
  visibilityCondition: defaultVisibilityCondition
}; // function useRefCallback(): [null | HTMLElement, Function] {
//   const [elem, setELem] = React.useState(null);
//   const elemCallbackRef: IRefFunctionCallback = React.useCallback(elem => {
//     setELem(elem);
//     elemCallbackRef.current = elem;
//   }, []);
//   return [elem, elemCallbackRef];
// }

function useIntersectionObserver(options) {
  var _defaultOptions$optio = _extends({}, defaultOptions, {}, options),
      rootMargin = _defaultOptions$optio.rootMargin,
      threshold = _defaultOptions$optio.threshold,
      when = _defaultOptions$optio.when,
      callback = _defaultOptions$optio.callback,
      visibilityCondition = _defaultOptions$optio.visibilityCondition;

  var _useRefCallback = useRefCallback(),
      rootElemNew = _useRefCallback[0],
      rootCallbackRef = _useRefCallback[1];

  var _useRefCallback2 = useRefCallback(),
      boxElem = _useRefCallback2[0],
      boxElemCallback = _useRefCallback2[1];

  var _React$useReducer = React.useReducer(IntersectionObserverReducer, initialState),
      state = _React$useReducer[0],
      dispatch = _React$useReducer[1];

  var observerInState = state.observerInState,
      isVisible = state.isVisible;
  var observerRef = React.useRef(null);
  var callbackRef = React.useRef(null);

  function callbackResolved(entries, observer) {
    entries.forEach(function (entry) {
      // setIntersectionObj(entry);
      dispatch({
        type: 'SETINTERSECTIONOBJ',
        data: entry
      });

      if (!observerInState) {
        dispatch({
          type: 'SETOBSERVERHANDLE',
          data: observer
        }); // setObserver(observer);
      }

      var finalVisibilityFunction = defaultVisibilityCondition;

      if (visibilityCondition) {
        finalVisibilityFunction = visibilityCondition;
      }

      dispatch({
        type: 'SET_VISIBILITY',
        data: finalVisibilityFunction(entry)
      }); // Each entry describes an intersection change for one observed
      // target element:
      //   entry.boundingClientRect
      //   entry.intersectionRatio
      //   entry.intersectionRect
      //   entry.isIntersecting
      //   entry.rootBounds
      //   entry.target
      //   entry.time
    });
  }

  var newCallbackDefault = React.useRef(callbackResolved);
  React.useEffect(function () {
    newCallbackDefault.current = callbackResolved;
  });
  /**
   * Setting callback Ref
   */

  React.useEffect(function () {
    if (!checkFeasibility) {
      return;
    }

    if (!callback) {
      var callbackDefault = newCallbackDefault.current;
      callbackRef.current = callbackDefault;
    } else {
      callbackRef.current = callback;
    }
  }, [callback, visibilityCondition, newCallbackDefault]);
  /**
   * unobserving intersectionobserver when "when" key is false
   */

  React.useEffect(function () {
    if (!checkFeasibility) {
      return;
    }

    if (!when) {
      if (observerRef.current && observerRef.current != null && boxElem) {
        observerRef.current.unobserve(boxElem);
      }
    }
  }, [observerRef, boxElem, when]);
  /**
   * Effect responsible for creating intersection observer and
   * registering the observer for specific element
   */

  React.useEffect(function () {
    if (!checkFeasibility) {
      return;
    }

    var currentELem = boxElem;
    var currentRootElem = rootElemNew;

    if (when) {
      var observer = new IntersectionObserver(callbackRef.current, {
        root: currentRootElem || null,
        threshold: threshold.split(',').map(function (elem) {
          return parseFloat(elem);
        }),
        rootMargin: rootMargin
      });
      observerRef.current = observer;

      if (currentELem && observerRef.current) {
        observerRef.current.observe(currentELem);
      }
    }

    return function () {
      if (currentELem && observerRef.current) {
        observerRef.current.unobserve(currentELem);
      }
    };
  }, [boxElem, rootElemNew, rootMargin, when, callbackRef, threshold]);
  return [isVisible, boxElemCallback, rootCallbackRef];
}

function useHotRefs(value) {
  var callbackRef = React.useRef(value);
  React.useEffect(function () {
    callbackRef.current = value;
  });
  return [callbackRef];
}

var defaultVisibilityCondition$1 = function defaultVisibilityCondition(entry) {
  if (entry.intersectionRatio >= 1) {
    return true;
  }

  return false;
};

var defaultOptions$1 = {
  rootMargin: '0px 0px 0px 0px',
  threshold: '0, 1',
  when: true,
  visibilityCondition: defaultVisibilityCondition$1
};

function LoadingMore() {
  return React.createElement("h1", null, "Loading More...");
}
/**
 * Custom useInfiniteScroll hook which use useIntersectionObserver custom hook
 *
 */


function useInfiniteScroll(options) {
  var _useIntersectionObser = useIntersectionObserver(options || defaultOptions$1),
      isVisible = _useIntersectionObser[0],
      boxElemCallback = _useIntersectionObser[1],
      rootCallbackRef = _useIntersectionObser[2];

  return [boxElemCallback, isVisible, rootCallbackRef];
}
/**
 * InfiniteScroll
 * @param props Infinite scroll component which uses above custom hooks
 */


function InfiniteScroll(props) {
  var callback = props.callback,
      _props$options = props.options,
      options = _props$options === void 0 ? defaultOptions$1 : _props$options,
      _props$LoadMoreCompon = props.LoadMoreComponent,
      LoadMoreComponent = _props$LoadMoreCompon === void 0 ? null : _props$LoadMoreCompon,
      _props$whenInfiniteSc = props.whenInfiniteScroll,
      whenInfiniteScroll = _props$whenInfiniteSc === void 0 ? true : _props$whenInfiniteSc;

  var finalOptions = _extends({}, defaultOptions$1, {}, options);

  var _useHotRefs = useHotRefs(callback),
      callbackRef = _useHotRefs[0];

  var _useInfiniteScroll = useInfiniteScroll(_extends({}, finalOptions, {
    when: whenInfiniteScroll
  })),
      boxElemCallback = _useInfiniteScroll[0],
      isVisible = _useInfiniteScroll[1];

  var callbackFixed = React.useCallback(function (isVisible) {
    if (whenInfiniteScroll && callbackRef.current) {
      var currentFunction = callbackRef.current;
      currentFunction(isVisible);
    }
  }, [callbackRef, whenInfiniteScroll]);
  React.useEffect(function () {
    if (callbackFixed && whenInfiniteScroll) {
      callbackFixed(isVisible);
    }
  }, [isVisible, callbackFixed, whenInfiniteScroll]);
  var finalReturnChildren = [];

  if (props.children) {
    /**
     * props.children can be  array like this, hence need to handle this scenario
     * flatten the children array
     * 0: {$$typeof: Symbol(react.element), type: "h1", key: null, ref: null, props: {…}, …}
     * 1: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
     *
     * In that case JSX will be like this :
     *
     * <Child>
        <div>Hi</div>
         <div>Hi</div>
         <div>Hi</div>
         {[1,2,3].map((elem, index) => {
           return <div key={index}>{index}</div>
         })}
         <div>
           
          </div>
      </Child>
     */
    var flattenChildren = [];
    React.Children.forEach(props.children, function (child) {
      if (Array.isArray(child)) {
        flattenChildren = [].concat(flattenChildren, child);
      } else {
        flattenChildren = [].concat(flattenChildren, [child]);
      }
    });
    finalReturnChildren = React.Children.map(flattenChildren, function (child, index) {
      var lastIndex = flattenChildren.length - 1;

      if (index === lastIndex) {
        //   if (!child) return null;
        return React.cloneElement(child, {
          ref: boxElemCallback
        });
      }

      return child;
    }).filter(function (elem) {
      return elem;
    });
  }

  if (isVisible && finalReturnChildren) {
    finalReturnChildren = [].concat(finalReturnChildren, [LoadMoreComponent ? React.cloneElement(LoadMoreComponent, {
      key: Math.random()
    }) : React.createElement(LoadingMore, {
      key: Math.random()
    })
    /**
     * Need to think about the correct key value. because this
     * key value may be same as one of the key in list item, right now using Math.random
     */
    ]);
  }

  return React.createElement(React.Fragment, null, finalReturnChildren);
}

export { InfiniteScroll };
//# sourceMappingURL=react-infinite-scroll.esm.js.map
