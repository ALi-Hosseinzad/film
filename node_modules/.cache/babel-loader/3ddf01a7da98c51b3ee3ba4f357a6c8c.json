{"ast":null,"code":"import { useRef, useState, useLayoutEffect } from 'react';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n/**\n * An infinite scroller based on effects.\n * Every time the loader is `N`px to be shown, switch to a new page, load new items.\n *\n * @example\n * const [items, setItems] = useState([]);\n * const [hasMore, setHasMore] = useState(false);\n * const [page, loaderRef, scrollerRef] = useInfiniteScroll({ hasMore });\n *\n * useFetchEffect(async ({ signal }) => {\n *   const data = await myApiCall({ page }, { signal });\n *   setHasMore(data.hasMore);\n *   setItems(prev => [...prev, data.items]);\n * }, [page])\n *\n * return (\n *   <div ref={scrollerRef}>\n *     {items.map(item => <div key={item.id}>{item.name}</div>)}\n *     {hasMore && <div ref={loaderRef}>Loading…</div>}\n *   </div>\n * );\n * @param {Object} [options={}]\n * @param {boolean} options.hasMore The observer will disconnect when there are no more items to load.\n * @param {boolean} [options.reset=false] Pass true when you're re-fetching the list and want to resets the scroller to page 0.\n * @param {number} [options.distance=250] When scrolling, the distance in pixels from the bottom to switch the page.\n */\n\n\nfunction useInfiniteScroll(_ref) {\n  var hasMore = _ref.hasMore,\n      _ref$reset = _ref.reset,\n      reset = _ref$reset === void 0 ? false : _ref$reset,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === void 0 ? 250 : _ref$distance;\n  var scrollContainerRef = useRef();\n  var loaderRef = useRef();\n\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      page = _useState2[0],\n      setPage = _useState2[1];\n\n  if (reset && page !== 0) {\n    setPage(0);\n  }\n\n  useLayoutEffect(function () {\n    var loaderNode = loaderRef.current;\n    var scrollContainerNode = scrollContainerRef.current;\n    if (!scrollContainerNode || !loaderNode || !hasMore) return;\n    var options = {\n      root: scrollContainerNode,\n      rootMargin: \"0px 0px \".concat(distance, \"px 0px\")\n    };\n    var previousY;\n    var previousRatio = 0;\n\n    var listener = function listener(entries) {\n      entries.forEach(function (_ref2) {\n        var isIntersecting = _ref2.isIntersecting,\n            intersectionRatio = _ref2.intersectionRatio,\n            _ref2$boundingClientR = _ref2.boundingClientRect,\n            boundingClientRect = _ref2$boundingClientR === void 0 ? {} : _ref2$boundingClientR;\n        var y = boundingClientRect.y;\n\n        if (isIntersecting && intersectionRatio >= previousRatio && (!previousY || y < previousY)) {\n          setPage(function (page) {\n            return page + 1;\n          });\n        }\n\n        previousY = y;\n        previousRatio = intersectionRatio;\n      });\n    };\n\n    var observer = new IntersectionObserver(listener, options);\n    observer.observe(loaderNode);\n    return function () {\n      return observer.disconnect();\n    };\n  }, [hasMore, distance]);\n  return [page, loaderRef, scrollContainerRef];\n}\n\nexport default useInfiniteScroll;","map":{"version":3,"sources":["../src/index.js"],"names":["hasMore","reset","distance","scrollContainerRef","useRef","loaderRef","page","setPage","useState","useLayoutEffect","loaderNode","scrollContainerNode","options","root","rootMargin","previousRatio","listener","entries","isIntersecting","intersectionRatio","boundingClientRect","y","previousY","observer"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0Be,SAAA,iBAAA,CAAA,IAAA,EAIZ;AAAA,MAHDA,OAGC,GAAA,IAAA,CAHDA,OAGC;AAAA,MAAA,UAAA,GAAA,IAAA,CAFDC,KAEC;AAAA,MAFDA,KAEC,GAAA,UAAA,KAAA,KAAA,CAAA,GAFO,KAEP,GAAA,UAAA;AAAA,MAAA,aAAA,GAAA,IAAA,CADDC,QACC;AAAA,MADDA,QACC,GAAA,aAAA,KAAA,KAAA,CAAA,GADU,GACV,GAAA,aAAA;AACD,MAAMC,kBAAkB,GAAGC,MAA3B,EAAA;AACA,MAAMC,SAAS,GAAGD,MAAlB,EAAA;;AAFC,MAAA,SAAA,GAGuBI,QAAQ,CAH/B,CAG+B,CAH/B;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAA,MAGMF,IAHN,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAGYC,OAHZ,GAAA,UAAA,CAAA,CAAA,CAAA;;AAKD,MAAIN,KAAK,IAAIK,IAAI,KAAjB,CAAA,EAAyB;AACvBC,IAAAA,OAAO,CAAPA,CAAO,CAAPA;AACD;;AAEDE,EAAAA,eAAe,CAAC,YAAM;AACpB,QAAMC,UAAU,GAAGL,SAAS,CAA5B,OAAA;AACA,QAAMM,mBAAmB,GAAGR,kBAAkB,CAA9C,OAAA;AACA,QAAI,CAAA,mBAAA,IAAwB,CAAxB,UAAA,IAAuC,CAA3C,OAAA,EAAqD;AAErD,QAAMS,OAAO,GAAG;AACdC,MAAAA,IAAI,EADU,mBAAA;AAEdC,MAAAA,UAAU,EAAA,WAAA,MAAA,CAAA,QAAA,EAAA,QAAA;AAFI,KAAhB;AAKA,QAAA,SAAA;AACA,QAAIC,aAAa,GAAjB,CAAA;;AAEA,QAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAA,OAAA,EAAW;AAC1BC,MAAAA,OAAO,CAAPA,OAAAA,CACE,UAAA,KAAA,EAAoE;AAAA,YAAjEC,cAAiE,GAAA,KAAA,CAAjEA,cAAiE;AAAA,YAAjDC,iBAAiD,GAAA,KAAA,CAAjDA,iBAAiD;AAAA,YAAA,qBAAA,GAAA,KAAA,CAA9BC,kBAA8B;AAAA,YAA9BA,kBAA8B,GAAA,qBAAA,KAAA,KAAA,CAAA,GAAT,EAAS,GAAA,qBAAA;AAAA,YAC1DC,CAD0D,GACpDD,kBADoD,CAAA,CAAA;;AAElE,YACEF,cAAc,IACdC,iBAAiB,IADjBD,aAAAA,KAEC,CAAA,SAAA,IAAcG,CAAC,GAHlB,SACEH,CADF,EAIE;AACAX,UAAAA,OAAO,CAAC,UAAA,IAAA,EAAI;AAAA,mBAAID,IAAI,GAAR,CAAA;AAAZC,WAAO,CAAPA;AACD;;AACDe,QAAAA,SAAS,GAATA,CAAAA;AACAP,QAAAA,aAAa,GAAbA,iBAAAA;AAXJE,OAAAA;AADF,KAAA;;AAiBA,QAAMM,QAAQ,GAAG,IAAA,oBAAA,CAAA,QAAA,EAAjB,OAAiB,CAAjB;AACAA,IAAAA,QAAQ,CAARA,OAAAA,CAAAA,UAAAA;AAEA,WAAO,YAAA;AAAA,aAAMA,QAAQ,CAAd,UAAMA,EAAN;AAAP,KAAA;AAjCa,GAAA,EAkCZ,CAAA,OAAA,EAlCHd,QAkCG,CAlCY,CAAfA;AAoCA,SAAO,CAAA,IAAA,EAAA,SAAA,EAAP,kBAAO,CAAP;AACD","sourcesContent":["import { useRef, useState, useLayoutEffect } from 'react';\n\n/**\n * An infinite scroller based on effects.\n * Every time the loader is `N`px to be shown, switch to a new page, load new items.\n *\n * @example\n * const [items, setItems] = useState([]);\n * const [hasMore, setHasMore] = useState(false);\n * const [page, loaderRef, scrollerRef] = useInfiniteScroll({ hasMore });\n *\n * useFetchEffect(async ({ signal }) => {\n *   const data = await myApiCall({ page }, { signal });\n *   setHasMore(data.hasMore);\n *   setItems(prev => [...prev, data.items]);\n * }, [page])\n *\n * return (\n *   <div ref={scrollerRef}>\n *     {items.map(item => <div key={item.id}>{item.name}</div>)}\n *     {hasMore && <div ref={loaderRef}>Loading…</div>}\n *   </div>\n * );\n * @param {Object} [options={}]\n * @param {boolean} options.hasMore The observer will disconnect when there are no more items to load.\n * @param {boolean} [options.reset=false] Pass true when you're re-fetching the list and want to resets the scroller to page 0.\n * @param {number} [options.distance=250] When scrolling, the distance in pixels from the bottom to switch the page.\n */\nexport default function useInfiniteScroll({\n  hasMore,\n  reset = false,\n  distance = 250,\n}) {\n  const scrollContainerRef = useRef();\n  const loaderRef = useRef();\n  const [page, setPage] = useState(0);\n\n  if (reset && page !== 0) {\n    setPage(0);\n  }\n\n  useLayoutEffect(() => {\n    const loaderNode = loaderRef.current;\n    const scrollContainerNode = scrollContainerRef.current;\n    if (!scrollContainerNode || !loaderNode || !hasMore) return;\n\n    const options = {\n      root: scrollContainerNode,\n      rootMargin: `0px 0px ${distance}px 0px`,\n    };\n\n    let previousY;\n    let previousRatio = 0;\n\n    const listener = entries => {\n      entries.forEach(\n        ({ isIntersecting, intersectionRatio, boundingClientRect = {} }) => {\n          const { y } = boundingClientRect;\n          if (\n            isIntersecting &&\n            intersectionRatio >= previousRatio &&\n            (!previousY || y < previousY)\n          ) {\n            setPage(page => page + 1);\n          }\n          previousY = y;\n          previousRatio = intersectionRatio;\n        },\n      );\n    };\n\n    const observer = new IntersectionObserver(listener, options);\n    observer.observe(loaderNode);\n\n    return () => observer.disconnect();\n  }, [hasMore, distance]);\n\n  return [page, loaderRef, scrollContainerRef];\n}\n"]},"metadata":{},"sourceType":"module"}